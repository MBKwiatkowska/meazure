<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Meazure: ev::ParseNode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Meazure
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceev.html">ev</a>      </li>
      <li class="navelem"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">ev::ParseNode Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ev::ParseNode" -->
<p>Represents a node in the parse tree that is constructed by parsing the content model.  
 <a href="classev_1_1ParseNode.html#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for ev::ParseNode:</div>
<div class="dyncontent">
<div class="center"><img src="classev_1_1ParseNode__coll__graph.png" border="0" usemap="#ev_1_1ParseNode_coll__map" alt="Collaboration graph"/></div>
<map name="ev_1_1ParseNode_coll__map" id="ev_1_1ParseNode_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classev_1_1ParseNode-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structev_1_1ParseNode_1_1LessOp.html">LessOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by STL to compare two <a class="el" href="classev_1_1ParseNode.html" title="Represents a node in the parse tree that is constructed by parsing the content model.">ParseNode</a> objects.  <a href="structev_1_1ParseNode_1_1LessOp.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> { <br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4">End</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06">Epsilon</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787">Name</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85">Choice</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0">Seq</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17">Rep</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515">Opt</a>, 
<br/>
&#160;&#160;<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91">Plus</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parse node.  <a href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f2bac801675232374915968e477770a"></a><!-- doxytag: member="ev::ParseNode::NodeSet" ref="a2f2bac801675232374915968e477770a" args="" -->
typedef std::set&lt; <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> <br class="typebreak"/>
*, <a class="el" href="structev_1_1ParseNode_1_1LessOp.html">LessOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of parse nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c1f4f84c399d876da87cd499cb8e70a"></a><!-- doxytag: member="ev::ParseNode::NodeIter" ref="a9c1f4f84c399d876da87cd499cb8e70a" args="" -->
typedef NodeSet::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9c1f4f84c399d876da87cd499cb8e70a">NodeIter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over a set of parse nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85f6bb58e423e9e48f0073ca806319e9"></a><!-- doxytag: member="ev::ParseNode::NodeIter_c" ref="a85f6bb58e423e9e48f0073ca806319e9" args="" -->
typedef NodeSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a85f6bb58e423e9e48f0073ca806319e9">NodeIter_c</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant iterator over a set of parse nodes. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ab160ce1585e0e6c880297f573d5cbf6f">ParseNode</a> (<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a parse node of the specified type.  <a href="#ab160ce1585e0e6c880297f573d5cbf6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a865215af96800eead0937bc3e95b56fe">ParseNode</a> (<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> type, <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *left)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a parse node of the specified type and with the specified left child node.  <a href="#a865215af96800eead0937bc3e95b56fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0823945f344a5894e00109d29e408d2"></a><!-- doxytag: member="ev::ParseNode::~ParseNode" ref="ad0823945f344a5894e00109d29e408d2" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ad0823945f344a5894e00109d29e408d2">~ParseNode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a parse node instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a52c06c7ca589f5c4ae7bb0226e51f19b">CloneType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of this node.  <a href="#a52c06c7ca589f5c4ae7bb0226e51f19b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ab6e6e6d403ef70c30b04d9917d11e8d5">GetType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the parse node.  <a href="#ab6e6e6d403ef70c30b04d9917d11e8d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a6565c21b43dd5e5b8d1ad57af1fbfbba">IsEnd</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is a terminal node.  <a href="#a6565c21b43dd5e5b8d1ad57af1fbfbba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#abc1aa583fa10a837899eb6c80bf711d3">IsEpsilon</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is an any input node.  <a href="#abc1aa583fa10a837899eb6c80bf711d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ae90178fb0fa4f64c645fc40fcbe8ed56">IsName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node contains an element name.  <a href="#ae90178fb0fa4f64c645fc40fcbe8ed56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9a063565e41072fe06ec41979057f399">IsChoice</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is an OR'd choice node.  <a href="#a9a063565e41072fe06ec41979057f399"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9dde3081fa830b18f1da740cfc2e13b4">IsSeq</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the node is a sequence node.  <a href="#a9dde3081fa830b18f1da740cfc2e13b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a49dae4f39d199b290aa4f6eaeb1077f5">IsRep</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the cardinality of the node is zero of more.  <a href="#a49dae4f39d199b290aa4f6eaeb1077f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a45db0c9fc6ae0dc150631cfe8a9de9c8">IsOpt</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the cardinality of the node is zero or one.  <a href="#a45db0c9fc6ae0dc150631cfe8a9de9c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#abda94202c579966ebf0480e677a0e010">IsPlus</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the cardinality of the node is one or more.  <a href="#abda94202c579966ebf0480e677a0e010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a7e720c169a15a086571c586e111eb5f0">HaveLeft</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this node has a child on its left branch.  <a href="#a7e720c169a15a086571c586e111eb5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a2c29641b2b86a5e521c0d1dbec72cc22">HaveRight</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this node has a child on its right branch.  <a href="#a2c29641b2b86a5e521c0d1dbec72cc22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d4dace3f9cedc110edee0de3641e73d"></a><!-- doxytag: member="ev::ParseNode::SetLeft" ref="a0d4dace3f9cedc110edee0de3641e73d" args="(ParseNode *node)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a0d4dace3f9cedc110edee0de3641e73d">SetLeft</a> (<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified parse node as the left side child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88fb81164cfcf0d0af6da0babbafa87c"></a><!-- doxytag: member="ev::ParseNode::SetRight" ref="a88fb81164cfcf0d0af6da0babbafa87c" args="(ParseNode *node)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a88fb81164cfcf0d0af6da0babbafa87c">SetRight</a> (<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified parse node as the right side child of this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ad96eaa9100c6d5330b832e2ebf32eaf0">GetLeft</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the left branch child node of this node.  <a href="#ad96eaa9100c6d5330b832e2ebf32eaf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#af582c8cf9fc7ff466c6b4e4892d18469">GetRight</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right branch child node of this node.  <a href="#af582c8cf9fc7ff466c6b4e4892d18469"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ae439fca4a328f2d72134950d5481806b">GetRight</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right branch child node of this node.  <a href="#ae439fca4a328f2d72134950d5481806b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9d15e193e545b517398791b8fd97642c">SetSymbol</a> (const XML_Char *symbol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input symbol for this parse node.  <a href="#a9d15e193e545b517398791b8fd97642c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a44a46bc16d660ff09e8649a1ccb9161f">SetSymbol</a> (const <a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a> &amp;symbol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input symbol for this parse node.  <a href="#a44a46bc16d660ff09e8649a1ccb9161f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#af8a8fde807ca68719b83e561bb8dccc2">GetSymbol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input symbol for this parse node.  <a href="#af8a8fde807ca68719b83e561bb8dccc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a26c8604858c3e88050a1cf5aadba2f71">GetSymbolSet</a> (<a class="el" href="namespaceev.html#ae2a90caa1b9395bf42edb2f451535c84">SymbolSet</a> &amp;symbols) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified set with the input symbols for the parse tree.  <a href="#a26c8604858c3e88050a1cf5aadba2f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a00aab8be63bfa3dfb44b8e026d8fad"></a><!-- doxytag: member="ev::ParseNode::BuildFollowpos" ref="a5a00aab8be63bfa3dfb44b8e026d8fad" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a5a00aab8be63bfa3dfb44b8e026d8fad">BuildFollowpos</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-constructs the followpos function as described in section 3.9 of the Dragon book. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a3b1367e316872dfbdd890a55a96c1eb4">GetId</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this parse node.  <a href="#a3b1367e316872dfbdd890a55a96c1eb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a419cd8c321083488b3cf6e709a41befa">GetFirstpos</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nodes that comprise the firstpos() set as defined in section 3.9 of the Dragon book.  <a href="#a419cd8c321083488b3cf6e709a41befa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9d25e7f29be3191c51232ce243cb3e5e">GetFollowpos</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nodes that comprise the followpos() set as defined in section 3.9 of the Dragon book.  <a href="#a9d25e7f29be3191c51232ce243cb3e5e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5fa3860607dbb77464dcd6a2b4659f0"></a><!-- doxytag: member="ev::ParseNode::ResetId" ref="ae5fa3860607dbb77464dcd6a2b4659f0" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ae5fa3860607dbb77464dcd6a2b4659f0">ResetId</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the ID assigned to the parse nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a327f32856c218056887aac463f01fee0">Union</a> (<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;set1, const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;set2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set union on the two specified sets of nodes.  <a href="#a327f32856c218056887aac463f01fee0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a50b8b076e4ff3895f9716185c392a9c6">EqualOp</a> (const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *n1, const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *n2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the two specified parse nodes are equal.  <a href="#a50b8b076e4ff3895f9716185c392a9c6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9e7dbba71bb671db07d8a325701655"></a><!-- doxytag: member="ev::ParseNode::ParseNode" ref="a9c9e7dbba71bb671db07d8a325701655" args="(const ParseNode &amp;node)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9c9e7dbba71bb671db07d8a325701655">ParseNode</a> (const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> &amp;node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Purposely undefined. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f77c07fbaeb03288f9dd5f62d7c44d9"></a><!-- doxytag: member="ev::ParseNode::operator=" ref="a8f77c07fbaeb03288f9dd5f62d7c44d9" args="(const ParseNode &amp;node)" -->
<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a8f77c07fbaeb03288f9dd5f62d7c44d9">operator=</a> (const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> &amp;node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Purposely undefined. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8f27689dc35d3b06237616cbb4cc205"></a><!-- doxytag: member="ev::ParseNode::Nullable" ref="ad8f27689dc35d3b06237616cbb4cc205" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the nullable() function as defined in section 3.9 of the Dragon book. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043aec49a1c2e543c546c9cd72d6cc61"></a><!-- doxytag: member="ev::ParseNode::Firstpos" ref="a043aec49a1c2e543c546c9cd72d6cc61" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the firstpos() function as defined in section 3.9 of the Dragon book. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a518da96b98058bcb0b65f156ec7d1f92"></a><!-- doxytag: member="ev::ParseNode::Lastpos" ref="a518da96b98058bcb0b65f156ec7d1f92" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the lastpos() function as defined in section 3.9 of the Dragon book. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c7333bbbb36c5d795f11195a7d67dae"></a><!-- doxytag: member="ev::ParseNode::Followpos" ref="a5c7333bbbb36c5d795f11195a7d67dae" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the followpos() function as defined in section 3.9 of the Dragon book. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae3e2c07f86de2697ec17538e2cb2dce"></a><!-- doxytag: member="ev::ParseNode::m_id" ref="aae3e2c07f86de2697ec17538e2cb2dce" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#aae3e2c07f86de2697ec17538e2cb2dce">m_id</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ID for this parse node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb6da4a1d7ef54aad3d702e1478674c"></a><!-- doxytag: member="ev::ParseNode::m_type" ref="a5eb6da4a1d7ef54aad3d702e1478674c" args="" -->
<a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse node's type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d2a504af18d57605f86ca2e39fdf98"></a><!-- doxytag: member="ev::ParseNode::m_left" ref="a41d2a504af18d57605f86ca2e39fdf98" args="" -->
<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse node's left child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f60fc8a42bd62e2e8fa9d77be0eaee1"></a><!-- doxytag: member="ev::ParseNode::m_right" ref="a0f60fc8a42bd62e2e8fa9d77be0eaee1" args="" -->
<a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse node's right child node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52c14d1e491c8ae7b92a8fc3d061aba2"></a><!-- doxytag: member="ev::ParseNode::m_symbol" ref="a52c14d1e491c8ae7b92a8fc3d061aba2" args="" -->
<a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input symbol. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d6253e9d47c7343fcdcb2ed22323f1b"></a><!-- doxytag: member="ev::ParseNode::m_nullable" ref="a6d6253e9d47c7343fcdcb2ed22323f1b" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a6d6253e9d47c7343fcdcb2ed22323f1b">m_nullable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>true</b> if the node is nullable. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac98655dcf276149ddc00bbdf3b9c41"></a><!-- doxytag: member="ev::ParseNode::m_firstPos" ref="a0ac98655dcf276149ddc00bbdf3b9c41" args="" -->
<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a0ac98655dcf276149ddc00bbdf3b9c41">m_firstPos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes that satisfy firstpos() for this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79c69d338100b5b7545c0cf0bbebd8ee"></a><!-- doxytag: member="ev::ParseNode::m_lastPos" ref="a79c69d338100b5b7545c0cf0bbebd8ee" args="" -->
<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a79c69d338100b5b7545c0cf0bbebd8ee">m_lastPos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes that satisfy lastpos() for this node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fd795e3f628cafbe31ff30b5541f156"></a><!-- doxytag: member="ev::ParseNode::m_followPos" ref="a2fd795e3f628cafbe31ff30b5541f156" args="" -->
<a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a2fd795e3f628cafbe31ff30b5541f156">m_followPos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes that satisfy followpos() for this node. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a775e7f1efb1e722564bf642e582af7"></a><!-- doxytag: member="ev::ParseNode::m_currentId" ref="a9a775e7f1efb1e722564bf642e582af7" args="" -->
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a9a775e7f1efb1e722564bf642e582af7">m_currentId</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ID to assign to the parse node created next. <br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classev_1_1ParseNode.html#a576585ce4e9703ca48a7dd36addd6729">operator&lt;&lt;</a> (<a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp;stream, const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for a parse node.  <a href="#a576585ce4e9703ca48a7dd36addd6729"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents a node in the parse tree that is constructed by parsing the content model. </p>
<p>Creating a parse tree is the first step in creating a <a class="el" href="classev_1_1DFA.html" title="This class represents a deterministic finite state automaton (DFA) (i.e.">DFA</a> for an element's content model. The parse tree is constructed according to the technique presented in algorithm 3.5 from the Dragon book. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcb"></a><!-- doxytag: member="ev::ParseNode::Type" ref="a5033886db86b646a9ac1f20d8ff37dcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">ev::ParseNode::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the parse node. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4"></a><!-- doxytag: member="End" ref="a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4" args="" -->End</em>&nbsp;</td><td>
<p>Terminal node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06"></a><!-- doxytag: member="Epsilon" ref="a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06" args="" -->Epsilon</em>&nbsp;</td><td>
<p>The any input node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787"></a><!-- doxytag: member="Name" ref="a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787" args="" -->Name</em>&nbsp;</td><td>
<p>An element name node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85"></a><!-- doxytag: member="Choice" ref="a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85" args="" -->Choice</em>&nbsp;</td><td>
<p>An OR'd choice node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0"></a><!-- doxytag: member="Seq" ref="a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0" args="" -->Seq</em>&nbsp;</td><td>
<p>A sequence node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17"></a><!-- doxytag: member="Rep" ref="a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17" args="" -->Rep</em>&nbsp;</td><td>
<p>A zero or more node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515"></a><!-- doxytag: member="Opt" ref="a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515" args="" -->Opt</em>&nbsp;</td><td>
<p>A zero or one node. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91"></a><!-- doxytag: member="Plus" ref="a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91" args="" -->Plus</em>&nbsp;</td><td>
<p>A one or mode node. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab160ce1585e0e6c880297f573d5cbf6f"></a><!-- doxytag: member="ev::ParseNode::ParseNode" ref="ab160ce1585e0e6c880297f573d5cbf6f" args="(Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseNode::ParseNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a parse node of the specified type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>[in] Parse node type. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classev_1_1ParseNode.html#a52c06c7ca589f5c4ae7bb0226e51f19b">CloneType()</a>.</p>

</div>
</div>
<a class="anchor" id="a865215af96800eead0937bc3e95b56fe"></a><!-- doxytag: member="ev::ParseNode::ParseNode" ref="a865215af96800eead0937bc3e95b56fe" args="(Type type, ParseNode *left)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseNode::ParseNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a parse node of the specified type and with the specified left child node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>[in] Parse node type. </td></tr>
    <tr><td class="paramname">left</td><td>[in] Left child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a52c06c7ca589f5c4ae7bb0226e51f19b"></a><!-- doxytag: member="ev::ParseNode::CloneType" ref="a52c06c7ca589f5c4ae7bb0226e51f19b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a>* ev::ParseNode::CloneType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a copy of this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Copy of this node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#ab160ce1585e0e6c880297f573d5cbf6f">ParseNode()</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>.</p>

</div>
</div>
<a class="anchor" id="a50b8b076e4ff3895f9716185c392a9c6"></a><!-- doxytag: member="ev::ParseNode::EqualOp" ref="a50b8b076e4ff3895f9716185c392a9c6" args="(const ParseNode *n1, const ParseNode *n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ev::ParseNode::EqualOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests whether the two specified parse nodes are equal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>[in] First parse node </td></tr>
    <tr><td class="paramname">n2</td><td>[in] Second parse node</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if n1's ID == n2's ID. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a3b1367e316872dfbdd890a55a96c1eb4">GetId()</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1State.html#ad856a0091a576c2b2dcbf7a6e1818cec">ev::State::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a419cd8c321083488b3cf6e709a41befa"></a><!-- doxytag: member="ev::ParseNode::GetFirstpos" ref="a419cd8c321083488b3cf6e709a41befa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&amp; ev::ParseNode::GetFirstpos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the nodes that comprise the firstpos() set as defined in section 3.9 of the Dragon book. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Set of nodes comprising the firstpos() set. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a0ac98655dcf276149ddc00bbdf3b9c41">m_firstPos</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#a71e4eab1eda1338b96b160dc03e89e3a">ev::DFA::BuildComplexDFA()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d25e7f29be3191c51232ce243cb3e5e"></a><!-- doxytag: member="ev::ParseNode::GetFollowpos" ref="a9d25e7f29be3191c51232ce243cb3e5e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a>&amp; ev::ParseNode::GetFollowpos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the nodes that comprise the followpos() set as defined in section 3.9 of the Dragon book. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Set of nodes comprising the followpos() set. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a2fd795e3f628cafbe31ff30b5541f156">m_followPos</a>.</p>

</div>
</div>
<a class="anchor" id="a3b1367e316872dfbdd890a55a96c1eb4"></a><!-- doxytag: member="ev::ParseNode::GetId" ref="a3b1367e316872dfbdd890a55a96c1eb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev::ParseNode::GetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the ID of this parse node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ID of this parse node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#aae3e2c07f86de2697ec17538e2cb2dce">m_id</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1ParseNode.html#a50b8b076e4ff3895f9716185c392a9c6">EqualOp()</a>, and <a class="el" href="structev_1_1ParseNode_1_1LessOp.html#a5a5e4e63553df381de10bbbb406ed8df">ev::ParseNode::LessOp::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="ad96eaa9100c6d5330b832e2ebf32eaf0"></a><!-- doxytag: member="ev::ParseNode::GetLeft" ref="ad96eaa9100c6d5330b832e2ebf32eaf0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a>* ev::ParseNode::GetLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the left branch child node of this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Child node on the left branch or NULL if there is no left child. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a>.</p>

<p>Referenced by <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="af582c8cf9fc7ff466c6b4e4892d18469"></a><!-- doxytag: member="ev::ParseNode::GetRight" ref="af582c8cf9fc7ff466c6b4e4892d18469" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a>* ev::ParseNode::GetRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the right branch child node of this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Child node on the right branch or NULL if there is no right child. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ae439fca4a328f2d72134950d5481806b"></a><!-- doxytag: member="ev::ParseNode::GetRight" ref="ae439fca4a328f2d72134950d5481806b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classev_1_1ParseNode.html">ParseNode</a>* ev::ParseNode::GetRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the right branch child node of this node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Child node on the right branch or NULL if there is no right child. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>.</p>

</div>
</div>
<a class="anchor" id="af8a8fde807ca68719b83e561bb8dccc2"></a><!-- doxytag: member="ev::ParseNode::GetSymbol" ref="af8a8fde807ca68719b83e561bb8dccc2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a> ev::ParseNode::GetSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the input symbol for this parse node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Input symbol for this parse node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

<p>Referenced by <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a26c8604858c3e88050a1cf5aadba2f71"></a><!-- doxytag: member="ev::ParseNode::GetSymbolSet" ref="a26c8604858c3e88050a1cf5aadba2f71" args="(SymbolSet &amp;symbols) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParseNode::GetSymbolSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceev.html#ae2a90caa1b9395bf42edb2f451535c84">SymbolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>symbols</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the specified set with the input symbols for the parse tree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>[out] Set to be filled with the input symbols. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a26c8604858c3e88050a1cf5aadba2f71">GetSymbolSet()</a>, <a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a>, <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>, and <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#a71e4eab1eda1338b96b160dc03e89e3a">ev::DFA::BuildComplexDFA()</a>, <a class="el" href="classev_1_1ParseNode.html#a26c8604858c3e88050a1cf5aadba2f71">GetSymbolSet()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e6e6d403ef70c30b04d9917d11e8d5"></a><!-- doxytag: member="ev::ParseNode::GetType" ref="ab6e6e6d403ef70c30b04d9917d11e8d5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcb">Type</a> ev::ParseNode::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the type of the parse node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Parse node type. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

<p>Referenced by <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e720c169a15a086571c586e111eb5f0"></a><!-- doxytag: member="ev::ParseNode::HaveLeft" ref="a7e720c169a15a086571c586e111eb5f0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::HaveLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node has a child on its left branch. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if a child node exists on the left branch. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a41d2a504af18d57605f86ca2e39fdf98">m_left</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c29641b2b86a5e521c0d1dbec72cc22"></a><!-- doxytag: member="ev::ParseNode::HaveRight" ref="a2c29641b2b86a5e521c0d1dbec72cc22" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::HaveRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node has a child on its right branch. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if a child node exists on the right branch. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a0f60fc8a42bd62e2e8fa9d77be0eaee1">m_right</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, and <a class="el" href="namespaceev.html#a05cec3f506b3b5ba7a41a86ce69dd2f6">ev::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a063565e41072fe06ec41979057f399"></a><!-- doxytag: member="ev::ParseNode::IsChoice" ref="a9a063565e41072fe06ec41979057f399" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsChoice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the node is an OR'd choice node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the node is an OR'd choice node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba8321db25fae1552e3d91a8fc63174d85">Choice</a>, and <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a class="anchor" id="a6565c21b43dd5e5b8d1ad57af1fbfbba"></a><!-- doxytag: member="ev::ParseNode::IsEnd" ref="a6565c21b43dd5e5b8d1ad57af1fbfbba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the node is a terminal node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if node is a terminal node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbaffc2ef17f08dffb49931ae492115eec4">End</a>, and <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

</div>
</div>
<a class="anchor" id="abc1aa583fa10a837899eb6c80bf711d3"></a><!-- doxytag: member="ev::ParseNode::IsEpsilon" ref="abc1aa583fa10a837899eb6c80bf711d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsEpsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the node is an any input node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the node is an any input node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba571be90a20298fd4ca9b33113caefb06">Epsilon</a>, and <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a class="anchor" id="ae90178fb0fa4f64c645fc40fcbe8ed56"></a><!-- doxytag: member="ev::ParseNode::IsName" ref="ae90178fb0fa4f64c645fc40fcbe8ed56" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the node contains an element name. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the node contains an element name. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcbac59f55ecc129026bd3f81d10e103c787">Name</a>.</p>

</div>
</div>
<a class="anchor" id="a45db0c9fc6ae0dc150631cfe8a9de9c8"></a><!-- doxytag: member="ev::ParseNode::IsOpt" ref="a45db0c9fc6ae0dc150631cfe8a9de9c8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsOpt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the cardinality of the node is zero or one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the cardinality of the node is zero or one. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba428ec16d0c0757c93debc2fd1db70515">Opt</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a class="anchor" id="abda94202c579966ebf0480e677a0e010"></a><!-- doxytag: member="ev::ParseNode::IsPlus" ref="abda94202c579966ebf0480e677a0e010" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsPlus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the cardinality of the node is one or more. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the cardinality of the node is one or more. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba62c057b0e6b727223f79d2ffacb59f91">Plus</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>.</p>

</div>
</div>
<a class="anchor" id="a49dae4f39d199b290aa4f6eaeb1077f5"></a><!-- doxytag: member="ev::ParseNode::IsRep" ref="a49dae4f39d199b290aa4f6eaeb1077f5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsRep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the cardinality of the node is zero of more. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the cardinality of the node is zero or more. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba4c2237d82f94032a6d2ca15490af4e17">Rep</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dde3081fa830b18f1da740cfc2e13b4"></a><!-- doxytag: member="ev::ParseNode::IsSeq" ref="a9dde3081fa830b18f1da740cfc2e13b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev::ParseNode::IsSeq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the node is a sequence node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><b>true</b> if the node is a sequence node. </dd></dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a5eb6da4a1d7ef54aad3d702e1478674c">m_type</a>, and <a class="el" href="classev_1_1ParseNode.html#a5033886db86b646a9ac1f20d8ff37dcba764ec27bdd978f3d500d6c724dc7aed0">Seq</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#ad8f27689dc35d3b06237616cbb4cc205">Nullable()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d15e193e545b517398791b8fd97642c"></a><!-- doxytag: member="ev::ParseNode::SetSymbol" ref="a9d15e193e545b517398791b8fd97642c" args="(const XML_Char *symbol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ev::ParseNode::SetSymbol </td>
          <td>(</td>
          <td class="paramtype">const XML_Char *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the input symbol for this parse node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>[in] Input symbol for the parse node. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#aa0c6f2f5cf6f58b2bf2f92ad15cda426">ev::DFA::BuildParseTree()</a>.</p>

</div>
</div>
<a class="anchor" id="a44a46bc16d660ff09e8649a1ccb9161f"></a><!-- doxytag: member="ev::ParseNode::SetSymbol" ref="a44a46bc16d660ff09e8649a1ccb9161f" args="(const EVString &amp;symbol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ev::ParseNode::SetSymbol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceev.html#a6efc98031badec1ea51620e17b011892">EVString</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the input symbol for this parse node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>[in] Input symbol for the parse node. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classev_1_1ParseNode.html#a52c14d1e491c8ae7b92a8fc3d061aba2">m_symbol</a>.</p>

</div>
</div>
<a class="anchor" id="a327f32856c218056887aac463f01fee0"></a><!-- doxytag: member="ev::ParseNode::Union" ref="a327f32856c218056887aac463f01fee0" args="(NodeSet &amp;set1, const NodeSet &amp;set2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ev::ParseNode::Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html#a2f2bac801675232374915968e477770a">NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a set union on the two specified sets of nodes. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ set_1 = set_1 \cup set_2 \]" src="form_1.png"/>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">set1</td><td>[in, out] First set of the union. </td></tr>
    <tr><td class="paramname">set2</td><td>[in] Second set of the union. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classev_1_1DFA.html#a71e4eab1eda1338b96b160dc03e89e3a">ev::DFA::BuildComplexDFA()</a>, <a class="el" href="classev_1_1ParseNode.html#a043aec49a1c2e543c546c9cd72d6cc61">Firstpos()</a>, <a class="el" href="classev_1_1ParseNode.html#a5c7333bbbb36c5d795f11195a7d67dae">Followpos()</a>, and <a class="el" href="classev_1_1ParseNode.html#a518da96b98058bcb0b65f156ec7d1f92">Lastpos()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a576585ce4e9703ca48a7dd36addd6729"></a><!-- doxytag: member="ev::ParseNode::operator&lt;&lt;" ref="a576585ce4e9703ca48a7dd36addd6729" args="(EVOstream &amp;stream, const ParseNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceev.html#a4743eb632c73d36a5ebd732f402db521">EVOstream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classev_1_1ParseNode.html">ParseNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output stream operator for a parse node. </p>
<p>Used to dump the state of the parse node to the specified output stream for debugging purposes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>[in] Output stream. </td></tr>
    <tr><td class="paramname">node</td><td>[in] Parse node to output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Output stream. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>exval.cpp</li>
</ul>
</div>
<hr size="1">
<address style="align: right;"><small>
Generated on Sun Sep 4 2011 10:54:39 for Meazure by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0>
</a> 1.7.5.1</small></address>
<address style="align: right;"><small>
Copyright 2011 C Thing Software
</small></address>
</body>
</html>
